// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "/Engine/Private/Common.ush"

// Statistical operators representing BSDF as a sum of lobes.
// This implementation is based on [Belcour 2018, "Efficient Rendering of Layered Materials using an Atomic Decomposition with Statistical Operators"]

struct StrataLobeStatistic
{
	// Mean
	// xy is the 2d projection of the lobe main direction onto the plane defined by the surface normal. 
	float2 Mu;

	// Energy
	float3 E;

	// Variance
	float Sigma;
};



float StrataLobeRoughnessToVariance(float Roughness)
{
	const float SafeRoughness = clamp(Roughness, 0.0f, 0.999f);
	return pow(SafeRoughness, 1.1f) / (1.0f - SafeRoughness);
}

float StrataLobeVarianceToRoughness(float Variance)
{
	return pow(Variance / (1.0f + Variance), 1.0f / 1.1f);
}



// For the following statistical operators
//  - WiLobe: the lobe towards which light is reflected
//  - InterfaceRoughness = the material layer roughness
//  - InterfaceFDG = the material layer directional albedo
//  - InterfaceEta12 = the ratio of refractive mediaEta1 / Eta2
//  - OpticalDepth = the value impact light transmission (= sigma_t * depth)
//  - Approximation to in-scattering from the back of the layer (eq.19)

StrataLobeStatistic StrataGetNullLobe()
{
	StrataLobeStatistic NullLobe = (StrataLobeStatistic)0;
	return NullLobe;
}

StrataLobeStatistic StrataGetViewDiracLobe(float3 Wi)
{
	StrataLobeStatistic WiLobe;
	WiLobe.E = 1.0f;
	WiLobe.Mu = Wi.xy;
	WiLobe.Sigma = 0.0f;
	return WiLobe;
}

StrataLobeStatistic StrataGetReflectedLobe(StrataLobeStatistic WiLobe, float3 InterfaceFDG, float InterfaceRoughness)
{
	StrataLobeStatistic WoLobe;

	WoLobe.E = WiLobe.E * InterfaceFDG;

	WoLobe.Mu = WiLobe.Mu;

	WoLobe.Sigma = WiLobe.Sigma + StrataLobeRoughnessToVariance(InterfaceRoughness);

	return WoLobe;
}

StrataLobeStatistic StrataGetRefractedLobe(StrataLobeStatistic WiLobe, float3 InterfaceFDG, float InterfaceRoughness, float InterfaceEta12)
{
	StrataLobeStatistic WoLobe;

	WoLobe.E = WiLobe.E * (1.0f - InterfaceFDG);

	WoLobe.Mu.xy = WiLobe.Mu.xy * InterfaceEta12;

	//	const float S = 0.5f * (1.0f + InterfaceEta12 * (WiLobe.Mu.z / WoLobe.Mu.z));				// This respect eq.10 but it goes crazy and does not respect the roughness of a single front layer
	//	const float S = 0.5f * (1.0f + InterfaceEta12 * max(0.0, WiLobe.Mu.z / WoLobe.Mu.z));		// This respect the roughness range better but looks incorrect
	const float S = 1.0f;																			// ==> Until this is fully understood, do not scale anything.
	WoLobe.Sigma = (WiLobe.Sigma / InterfaceEta12) + StrataLobeRoughnessToVariance(S * InterfaceRoughness);

	return WoLobe;
}

StrataLobeStatistic StrataGetTransmittedLobe(StrataLobeStatistic WiLobe, float3 OpticalDepth)
{
	StrataLobeStatistic WoLobe;

	WoLobe.E = WiLobe.E * exp(-OpticalDepth);

	// Continue straight forward
	WoLobe.Mu = WiLobe.Mu;

	WoLobe.Sigma = WiLobe.Sigma;

	return WoLobe;
}

StrataLobeStatistic StrataWeightLobe(StrataLobeStatistic A, float Weight)
{
	// We simple weight the lob properties so that they progressively disapear as a function of coverage.
	// This is not entirely correct though because if matter coverage is reduced there should be two lobe: 
	//	- this lobe with visibility = coverage
	//	- a dirac lobe with visibility = 1 - coverage
	StrataLobeStatistic WoLobe = A;
	WoLobe.E *= Weight;
	WoLobe.Mu *= Weight;
	WoLobe.Sigma *= Weight;
	return WoLobe;
}

StrataLobeStatistic StrataHorizontalMixLobes(StrataLobeStatistic A, StrataLobeStatistic B, float Mix)
{
	StrataLobeStatistic WoLobe;
	WoLobe.E = lerp(A.E, B.E, Mix);
	WoLobe.Mu = lerp(A.Mu, B.Mu, Mix);
	WoLobe.Sigma = lerp(A.Sigma, B.Sigma, Mix);
	return WoLobe;
}

