// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../AreaLightCommon.ush"

// Sanity guard. 
#ifndef STRATA_ENABLED
	#define STRATA_ENABLED 1
	#error STRATA_ENABLED needs to be defined
#endif

#if STRATA_ENABLED

float4 StrataReadPrecomputedShadowFactors(FStrataPixelHeader StrataPixelHeader, int2 PixelPos, Texture2D PrecomputedShadowTexture)
{
	if (HasPrecShadowMask(StrataPixelHeader))
	{
	#if ALLOW_STATIC_LIGHTING
		float4 GBufferE = PrecomputedShadowTexture.Load(int3(PixelPos, 0));
	#else
		float4 GBufferE = 1;
	#endif
		return GBufferE;
	}
	return HasZeroPrecShadowMask(StrataPixelHeader) ? 0.0f : 1.0f;
}

// Analytical lighting evaluation for strata material.
// Unpack BSDF on-the-fly
float4 StrataDeferredLighting(
	FDeferredLightData LightData,
	float3 V,
	float3 L,
	float3 ToLight,
	float LightMask,
	FShadowTerms ShadowTerms,
	FStrataMaterialContainer MaterialBuffer,
	FStrataAddressing StrataAddressing,
	FStrataPixelHeader StrataPixelHeader)
{
	FLightAccumulator Out = (FLightAccumulator)0;
	const bool bForceFullyRough = false;

	FRectTexture RectTexture = InitRectTexture(LightData);

	Strata_for (uint BSDFIndex = 0; BSDFIndex < StrataPixelHeader.BSDFCount; ++BSDFIndex)
	{
		// Unpack BSDF data
		FStrataBSDF BSDF = UnpackStrataBSDF(MaterialBuffer, StrataAddressing, StrataPixelHeader);

		FStrataBSDFContext BSDFContext = StrataCreateBSDFContext(StrataPixelHeader, BSDF, StrataAddressing, V, L);

		float Roughness = StrataGetBSDFRoughness(BSDFContext.BSDF);

		FAreaLightIntegrateContext AreaLightContext = InitAreaLightIntegrateContext();
		FStrataEvaluateResult BSDFEvaluate = (FStrataEvaluateResult)0;
		if (LightData.bRectLight)
		{
			FRect Rect = GetRect(ToLight, LightData);
			if (!IsRectVisible(Rect))
			{
				return 0.0f; // Rect light can be non visible due to barn door occlusion
			}
			AreaLightContext = CreateRectIntegrateContext(Roughness, BSDFContext.N, BSDFContext.V, Rect, RectTexture);

			// We must have the StrataIntegrateBSDF inside the if due to the rectlight texture: it must be non ambiguous which texture is going to be used.
			// After the compilation, a local resource must map to a unique global resource (the default or the actual rect light texture).
			BSDFEvaluate = StrataIntegrateBSDF(BSDFContext, ShadowTerms, AreaLightContext, bForceFullyRough, Strata.bRoughDiffuse);
		}
		else
		{
			FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
			AreaLightContext = CreateCapsuleIntegrateContext(Roughness, BSDFContext.N, BSDFContext.V, Capsule, LightData.bInverseSquared);

			BSDFEvaluate = StrataIntegrateBSDF(BSDFContext, ShadowTerms, AreaLightContext, bForceFullyRough, Strata.bRoughDiffuse);
		}

		float3 DiffuseLuminance = BSDFEvaluate.IntegratedDiffuseValue;
		float3 SpecularLuminance = BSDFEvaluate.IntegratedSpecularValue;

		const bool bNeedsSeparateSubsurfaceLightAccumulation = BSDFEvaluate.bSubsurface;
		const float3 CommonMultiplier = LightData.Color * LightMask * BSDF.LuminanceWeight;
		LightAccumulator_AddSplit(Out, DiffuseLuminance, SpecularLuminance, DiffuseLuminance, CommonMultiplier, bNeedsSeparateSubsurfaceLightAccumulation);
	}

	const FDeferredLightingSplit SplitLighting = LightAccumulator_GetResultSplit(Out);
	const float4 OutRadiance = SplitLighting.SpecularLighting + SplitLighting.DiffuseLighting;
	return OutRadiance;
}

#endif // STRATA_ENABLED