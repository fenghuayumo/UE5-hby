
#include "/Engine/Private/Strata/StrataEvaluation.ush"
#include "/Engine/Private/ShadingCommon.ush"

#ifndef STRATA_OPAQUE_MATERIAL
#define STRATA_OPAQUE_MATERIAL 0
#endif



///////////////////////////////////////////////////////////////////////////////
// Utilities

void PostProcessSlabBeforeLighting(inout FStrataBSDF BSDF)
{
	// Two sided lighting can only be evaluated on the bottom layer, together with option SSS. Otherwise, the simple volume will be used.
	const bool bIsThin = BSDF.bIsBottom && BSDF_GETISTHIN(BSDF);

	// We want simple volumetric only if the DMFP input is pluged in, otherwise we avoid dealing with simple volumetric.
	// We also do not want to use the simple volumetric path if we are dealing with an opaque material and this slab is not at the bottom.
	// And when opaque, the bottom layer must be opaque and thus will ahve a solid opaque diffuse color.
	const bool bIsSimpleVolume = !bIsThin && BSDF_GETHASDMFP(BSDF) && (!STRATA_OPAQUE_MATERIAL || (STRATA_OPAQUE_MATERIAL && !BSDF.bIsBottom));

	if (bIsSimpleVolume)
	{
		EnableSlabBSDFSimpleVolumetric(BSDF);
	}

	if (bIsThin)
	{
		EnableSlabBSDFIsThin(BSDF);
	}
	else
	{
		// If not selected or not possible to have two sided lighting enabled (not bottom layer or SSSProfile is enabled), let's make sure we disable the feature.
		BSDF_SETISTHIN(BSDF, 0);
	}
}

void PostProcessBSDFBeforeLighting(inout FStrataBSDF BSDF)
{
	// Sanitize BSDF before it is used for forward shading
	StrataSanitizeBSDF(BSDF);

	switch (BSDF_GETTYPE(BSDF))
	{
	case STRATA_BSDF_TYPE_SLAB:
	{
		PostProcessSlabBeforeLighting(BSDF);
		break;
	}
	}
}



///////////////////////////////////////////////////////////////////////////////
// Tree processing functions

void UpdateSingleBSDFOperatorCoverageTransmittance(
	FStrataPixelHeader StrataPixelHeader,
	inout FStrataTree StrataTree, 
	inout FStrataBSDF CurrentBSDF,
	bool bRoughDiffuseEnabled,
	FStrataAddressing NullStrataAddressing,
	float3 V,
	float3 L
)
{
#if STRATA_INLINE_SHADING

	PostProcessBSDFBeforeLighting(CurrentBSDF);

	// Compute current BSDF transmittance
	FStrataBSDFContext StrataBSDFContext = StrataCreateBSDFContext(StrataPixelHeader, CurrentBSDF, NullStrataAddressing, V, L);
	FStrataEvaluateResult BSDFEvaluate = StrataEvaluateBSDF(StrataBSDFContext, bRoughDiffuseEnabled);

	float CurrentBSDFCoverage = CurrentBSDF.Coverage;
	float3 CurrentBSDFTransmittance = BSDFEvaluate.Throughput;

	// We multiply this weight with coverage:
	//  - Because when coming from parameter blending, we need to scale the output down according to coverage resulting from parameter blending.
	//  - That will be applied on emissive and reflected light, so we do not ned to apply that anywhere else.
	//  - When coming from non parameter blending, this is equal identity 1 and the operator parsing will continue to correctly weight the BSDF according to the tree.
	CurrentBSDF.LuminanceWeight = float3(1.0f, 1.0f, 1.0f) * CurrentBSDFCoverage;

	// All BSDF are considered for contribution as the top BSDF can have their coverage dip to 0 and then another BSDF need to be considered for the top layer representation.
	CurrentBSDF.TopLayerDataWeight = 1.0f;

	StrataTree.Operators[CurrentBSDF.OperatorIndex].Coverage = CurrentBSDFCoverage;
	StrataTree.Operators[CurrentBSDF.OperatorIndex].Transmittance = CurrentBSDFTransmittance;

	// The top layer we consider a transition air to water. For layers below, we assume they all have similar index of refraction.
	const float Roughness = StrataGetBSDFRoughness(CurrentBSDF);
	const FBxDFEnergyTerms EnergyTerms = ComputeGGXSpecEnergyTerms(Roughness, StrataBSDFContext.SatNoV, StrataGetBSDFSpecularColor(CurrentBSDF), StrataGetBSDFSpecularF90(CurrentBSDF));
	const float InterfaceEta12 = CurrentBSDF.bIsTop ? 1.0f / 1.33f : 1.0f; // STRATA_TODO Use Refraction.x in IOR mode? Or even the material IOR corresponding to F0?
	StrataLobeStatistic RefractedLobe = StrataGetRefractedLobe(StrataGetViewDiracLobe(-V), EnergyTerms.E, Roughness, InterfaceEta12);
	// Account for transmittance of the medium (but ignoring scattering for now)
	RefractedLobe.E *= CurrentBSDFTransmittance;
	// Account for coverate
	RefractedLobe = StrataWeightLobe(RefractedLobe, CurrentBSDFCoverage);
	StrataTree.Operators[CurrentBSDF.OperatorIndex].RefractionLobeStat = RefractedLobe;
	
	float3x3 TangentBasis = StrataGetBSDFSharedBasis_InlineShading(StrataPixelHeader, CurrentBSDF, NullStrataAddressing);
	StrataTree.Operators[CurrentBSDF.OperatorIndex].RefractionWorldNormal = TangentBasis[2];

#endif // STRATA_INLINE_SHADING
}


void UpdateSingleOperatorCoverageTransmittance(inout FStrataTree StrataTree, int OpIndex)
{
#if STRATA_INLINE_SHADING

#define Op StrataTree.Operators[OpIndex]
#define OpA StrataTree.Operators[StrataTree.Operators[OpIndex].LeftIndex]
#define OpB StrataTree.Operators[StrataTree.Operators[OpIndex].RightIndex]

	switch (Op.Type)
	{

	case STRATA_OPERATOR_WEIGHT:
	{
		const float Weight = saturate(Op.Weight);
		Op.Coverage = Weight * OpA.Coverage;
		Op.Transmittance = OpA.Transmittance;

		Op.RefractionLobeStat = StrataWeightLobe(OpA.RefractionLobeStat, Weight);
		Op.RefractionWorldNormal = OpA.RefractionWorldNormal * Weight;
		break;
	}

	case STRATA_OPERATOR_VERTICAL:
	{
		const float3 TopTransmittance = OpA.Transmittance;
		const float3 BotTransmittance = OpB.Transmittance;
		const float TopCoverage = OpA.Coverage;
		const float BotCoverage = OpB.Coverage;

#if 0
		// This is coverage assuming correlation
		const float LayerMaxCoverage = max(TopCoverage, BotCoverage);
		const float LayerMaxCoverageInv = LayerMaxCoverage <= 0.0f ? 1.0f : 1.0f / LayerMaxCoverage;

		// If a layer has a lower coverage than the other, we account for that when compuing the Transmittance.
		const float TransmittanceOne = 1.0f;
		const float3 TopTransmittanceAdjusted = lerp(TransmittanceOne, TopTransmittance, TopCoverage * LayerMaxCoverageInv);
		const float3 BotTransmittanceAdjusted = lerp(TransmittanceOne, BotTransmittance, BotCoverage * LayerMaxCoverageInv);

		// Now we update the material transmittance and coverage
		Op.Coverage = LayerMaxCoverage;
		Op.Transmittance = TopTransmittanceAdjusted * BotTransmittanceAdjusted;
#else
		FVerticalLayeringInfo Info = GetVerticalLayeringInfo(TopCoverage, BotCoverage);

		Op.Coverage					= Info.Coverage;
		Op.Transmittance			= Info.TransmittanceOnlyTop * TopTransmittance + Info.TransmittanceOnlyBottom * BotTransmittance + Info.TransmittanceTopAndBottom * TopTransmittance * BotTransmittance;
#endif

		Op.VerticalTopCoverage		= OpA.Coverage;
		Op.VerticalTopTransmittance = OpA.Transmittance;

		// Project top lob into bottom layer
		const float InterfaceEta12 = 1.0f; // STRATA_TODO We assume layers all have the same IOR. But we should take into account the material later.
		Op.RefractionLobeStat = StrataGetRefractedLobe(OpA.RefractionLobeStat, /*InterfaceFDG*/0.0f, StrataLobeVarianceToRoughness(OpB.RefractionLobeStat.Sigma), InterfaceEta12);
		Op.RefractionLobeStat.E *= OpB.RefractionLobeStat.E * saturate(Op.VerticalTopTransmittance + (1.0f - Op.VerticalTopCoverage)); // Combine with botton layer medium and specular transmittance

		// The ratio of bottomSurfaceVisbile and visible through top layer (with a scale of 0.5 because at maximum both surfaces will be visible) as a fonction of the total coverage.
		const float RefractionNormalMix = saturate((Info.SurfaceBottom + 0.5f * Info.TransmittanceTopAndBottom * dot(TopTransmittance, 0.33.xxx)) / max(STRATA_EPSILON, Info.Coverage));
		Op.RefractionWorldNormal = lerp(OpA.RefractionWorldNormal, OpB.RefractionWorldNormal, RefractionNormalMix);
		break;
	}

	case STRATA_OPERATOR_HORIZONTAL:
	{
		const float Mix = saturate(Op.Weight);
		const float AMix = 1.0 - Mix;
		const float BMix = Mix;

		Op.Coverage = AMix * OpA.Coverage + BMix * OpB.Coverage;
		Op.Transmittance = (AMix * OpA.Coverage * OpA.Transmittance + BMix * OpB.Coverage * OpB.Transmittance) / max(STRATA_EPSILON, AMix * OpA.Coverage + BMix * OpB.Coverage);

		Op.RefractionLobeStat = StrataHorizontalMixLobes(OpA.RefractionLobeStat, OpB.RefractionLobeStat, BMix);
		Op.RefractionWorldNormal = lerp(OpA.RefractionWorldNormal, OpB.RefractionWorldNormal, BMix);
		break;
	}

	case STRATA_OPERATOR_ADD:
	{
		const float SafeABSDFCoverage = saturate(OpA.Coverage);
		const float SafeBBSDFCoverage = saturate(OpB.Coverage);
		const float AMixFactor = SafeABSDFCoverage / max(STRATA_EPSILON, SafeABSDFCoverage + SafeBBSDFCoverage);

		Op.Coverage = saturate(OpA.Coverage + OpB.Coverage);
		Op.Transmittance = lerp(OpB.Transmittance, OpA.Transmittance, AMixFactor);

		Op.RefractionLobeStat = StrataHorizontalMixLobes(OpA.RefractionLobeStat, OpB.RefractionLobeStat, 0.5f);
		Op.RefractionWorldNormal = lerp(OpA.RefractionWorldNormal, OpB.RefractionWorldNormal, 0.5f);
		break;
	}

	}

#undef Op
#undef OpA
#undef OpB

#endif // STRATA_INLINE_SHADING
}



#define Op StrataTree.Operators[OpIndex]


void UpdateAllBSDFWithBottomUpOperatorVisit_Weight(
	inout FStrataTree StrataTree,
	inout FStrataBSDF CurrentBSDF,
	int OpIndex,
	int PreviousIsInputA)
{
#if STRATA_INLINE_SHADING

	const float Weight = saturate(Op.Weight);
	CurrentBSDF.LuminanceWeight *= Weight;
	CurrentBSDF.Coverage *= Weight;

	CurrentBSDF.TopLayerDataWeight *= Weight;

#endif // STRATA_INLINE_SHADING
}

void UpdateAllBSDFWithBottomUpOperatorVisit_Horizontal(
	inout FStrataTree StrataTree,
	inout FStrataBSDF CurrentBSDF,
	int OpIndex,
	int PreviousIsInputA)
{
#if STRATA_INLINE_SHADING

	const float Mix = saturate(Op.Weight);
	const float AMix = 1.0 - Mix;
	const float BMix = Mix;
	const float Weight = PreviousIsInputA > 0 ? AMix : BMix;
	CurrentBSDF.LuminanceWeight *= Weight;
	CurrentBSDF.Coverage *= Weight;

	CurrentBSDF.TopLayerDataWeight *= Weight;

#endif // STRATA_INLINE_SHADING
}

void UpdateAllBSDFWithBottomUpOperatorVisit_Vertical(
	inout FStrataTree StrataTree,
	inout FStrataBSDF CurrentBSDF,
	int OpIndex,
	int PreviousIsInputA)
{
#if STRATA_INLINE_SHADING

	// PreviousIsInputA > 0 means it is a BSDF affecting the top layer so we do not affect it by anything for this vertical layering.
	// Otherise, the BSDF comes from the bottom part so we affect it weights from the gathered top layer coverage/transmittance
	CurrentBSDF.LuminanceWeight *=
		PreviousIsInputA > 0 ? 1.0f : saturate(1.0f - Op.VerticalTopCoverage) + saturate(Op.VerticalTopCoverage) * Op.VerticalTopTransmittance;

	// If the BSDF is from the bottom, we reduce its contribution according to the top layer coverage only.
	CurrentBSDF.TopLayerDataWeight *= PreviousIsInputA ? 1.0 : saturate(1.0f - Op.VerticalTopCoverage);

#endif // STRATA_INLINE_SHADING
}

#undef Op



///////////////////////////////////////////////////////////////////////////////
// Legacy materials conversion

void LegacyUpdateBSDFsOperators(inout FStrataPixelHeader StrataPixelHeader, inout FStrataTree StrataTree, bool bRoughDiffuseEnabled, FStrataAddressing NullStrataAddressing, float3 V, float3 NullLightDir)
{
	// This must match what is done in StrataConvertLegacyMaterialDynamic
	UpdateSingleBSDFOperatorCoverageTransmittance(StrataPixelHeader, StrataTree, StrataTree.BSDFs[0], bRoughDiffuseEnabled, NullStrataAddressing, V, NullLightDir);
	UpdateSingleBSDFOperatorCoverageTransmittance(StrataPixelHeader, StrataTree, StrataTree.BSDFs[1], bRoughDiffuseEnabled, NullStrataAddressing, V, NullLightDir);

	// MaxDistanceFromLeaves = 1 
	UpdateSingleOperatorCoverageTransmittance(StrataTree, /*OperatorIndex*/2);
	UpdateSingleOperatorCoverageTransmittance(StrataTree, /*OperatorIndex*/3);
	// MaxDistanceFromLeaves = 2 
	UpdateSingleOperatorCoverageTransmittance(StrataTree, /*OperatorIndex*/4);
#if STRATA_LEGACY_MATERIAL_APPLIES_FINAL_WEIGHT
	// MaxDistanceFromLeaves = 3 
	UpdateSingleOperatorCoverageTransmittance(StrataTree, /*OperatorIndex*/5);
#endif

	UpdateAllBSDFWithBottomUpOperatorVisit_Weight	(StrataTree, StrataTree.BSDFs[0], /*OperatorIndex*/2, /*PreviousIsInputA*/1);
	UpdateAllBSDFWithBottomUpOperatorVisit_Vertical	(StrataTree, StrataTree.BSDFs[0], /*OperatorIndex*/4, /*PreviousIsInputA*/1);
#if STRATA_LEGACY_MATERIAL_APPLIES_FINAL_WEIGHT
	UpdateAllBSDFWithBottomUpOperatorVisit_Weight	(StrataTree, StrataTree.BSDFs[0], /*OperatorIndex*/5, /*PreviousIsInputA*/1);
#endif
	UpdateAllBSDFWithBottomUpOperatorVisit_Weight	(StrataTree, StrataTree.BSDFs[1], /*OperatorIndex*/3, /*PreviousIsInputA*/1);
	UpdateAllBSDFWithBottomUpOperatorVisit_Vertical	(StrataTree, StrataTree.BSDFs[1], /*OperatorIndex*/4, /*PreviousIsInputA*/0);
#if STRATA_LEGACY_MATERIAL_APPLIES_FINAL_WEIGHT
	UpdateAllBSDFWithBottomUpOperatorVisit_Weight	(StrataTree, StrataTree.BSDFs[1], /*OperatorIndex*/5, /*PreviousIsInputA*/1);
#endif
}


