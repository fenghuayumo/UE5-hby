// Copyright Epic Games, Inc. All Rights Reserved.

using EpicGames.Core;
using EpicGames.Horde.Compute.Impl;
using EpicGames.Horde.Storage;
using EpicGames.Serialization;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace EpicGames.Horde.Compute
{
	/// <summary>
	/// Response decribing a cluster
	/// </summary>
	public interface IComputeClusterInfo
	{
		/// <summary>
		/// Id of the cluster
		/// </summary>
		public ClusterId Id { get; }

		/// <summary>
		/// Namespace containing the requests and responses
		/// </summary>
		public NamespaceId NamespaceId { get; }

		/// <summary>
		/// The request bucket id
		/// </summary>
		public BucketId RequestBucketId { get; }

		/// <summary>
		/// Bucket to store response refs
		/// </summary>
		public BucketId ResponseBucketId { get; }
	}

	/// <summary>
	/// State of a compute task
	/// </summary>
	public enum ComputeTaskState
	{
		/// <summary>
		/// The task is queued for execution
		/// </summary>
		Queued = 0,

		/// <summary>
		/// Currently being executed by a remote agent
		/// </summary>
		Executing = 1,

		/// <summary>
		/// Completed
		/// </summary>
		Complete = 2,
	}

	/// <summary>
	/// Outcome of a task, if it's in the complete state
	/// </summary>
	public enum ComputeTaskOutcome
	{
		/// <summary>
		/// The task was executed successfully
		/// </summary>
		Success = 0,

		/// <summary>
		/// The lease failed with an error
		/// </summary>
		Failed = 1,

		/// <summary>
		/// The lease was cancelled
		/// </summary>
		Cancelled = 2,

		/// <summary>
		/// The task ran but did not return a result for unknown reasons
		/// </summary>
		NoResult = 3,

		/// <summary>
		/// The item was not scheduled for execution in the default time period, and was expired.
		/// </summary>
		Expired = 4,

		/// <summary>
		/// A blob could not be found. The detail field includes the hash of the blob.
		/// </summary>
		BlobNotFound = 5,

		/// <summary>
		/// An uncaught exception occurred during task execution
		/// </summary>
		Exception = 6,
	}

	/// <summary>
	/// Supplies information about the current execution state of a task
	/// </summary>
	public interface IComputeTaskInfo
	{
		/// <summary>
		/// Reference to the task decriptor that was requested
		/// </summary>
		public RefId TaskRefId { get; }

		/// <summary>
		/// Time that the event happened
		/// </summary>
		public DateTime Time { get; }

		/// <summary>
		/// New state of the task
		/// </summary>
		public ComputeTaskState State { get; }

		/// <summary>
		/// Outcome of the task execution.Note that this reflects the outcome of the execution rather than the outcome of the task.        
		/// </summary>
		public ComputeTaskOutcome Outcome { get; }

		/// <summary>
		/// Additional information about the outcome of the task.Dependent on the value of Outcome.        
		/// </summary>
		public string? Detail { get; }

		/// <summary>
		/// Ref containing the task result
		/// </summary>
		public RefId? ResultRefId { get; }

		/// <summary>
		/// When transitioning to the executing state, includes the name of the agent performing the work
		/// </summary>
		public string? AgentId { get; }

		/// <summary>
		/// When transitioning to the executing state, includes the id of the lease assigned to the agent
		/// </summary>
		public string? LeaseId { get; }
	}

	/// <summary>
	/// Interface for communicating with a compute server
	/// </summary>
	public interface IComputeClient
	{
		/// <summary>
		/// Gets information about a cluster
		/// </summary>
		/// <param name="ClusterId">The cluster to retreive information on</param>
		/// <param name="CancellationToken">Cancellation token for the request</param>
		/// <returns>Cluster information</returns>
		Task<IComputeClusterInfo> GetClusterInfoAsync(ClusterId ClusterId, CancellationToken CancellationToken = default);

		/// <summary>
		/// Queues a set of tasks for execution
		/// </summary>
		/// <param name="ClusterId">Cluster for executing the tasks</param>
		/// <param name="ChannelId">Indicates an identifier generated by the client to query responses on</param>
		/// <param name="RequirementsHash">Requirements of the task to execute</param>
		/// <param name="TaskRefIds">Refs describing the request</param>
		/// <param name="SkipCacheLookup">Whether to skip the lookup of cached output for this task</param>
		/// <param name="CancellationToken">Cancellation token for the request</param>
		/// <returns>The new channel id</returns>
		Task AddTasksAsync(ClusterId ClusterId, ChannelId ChannelId, IEnumerable<RefId> TaskRefIds, IoHash RequirementsHash, bool SkipCacheLookup, CancellationToken CancellationToken = default);

		/// <summary>
		/// Read updates from the given remote execution channel
		/// </summary>
		/// <param name="ClusterId">Cluster for executing the tasks</param>
		/// <param name="ChannelId">Channel to receive updates on</param>
		/// <param name="CancellationToken">Cancellation token for the operation</param>
		/// <returns></returns>
		IAsyncEnumerable<IComputeTaskInfo> GetTaskUpdatesAsync(ClusterId ClusterId, ChannelId ChannelId, CancellationToken CancellationToken = default);
	}

	/// <summary>
	/// Extension methods for <see cref="IComputeClient"/>
	/// </summary>
	public static class ComputeClientExtensions
	{
		/// <summary>
		/// Queues a single task for execution
		/// </summary>
		/// <param name="ComputeClient">The compute client instance</param>
		/// <param name="ClusterId">Name of the profile to use for executing the tasks</param>
		/// <param name="ChannelId">Channel to receive updates on</param>
		/// <param name="TaskRefId">Ref describing the request</param>
		/// <param name="RequirementsHash">Requirements of the task to execute</param>
		/// <param name="SkipCacheLookup">Whether to skip the lookup of cached output for this task</param>
		/// <param name="CancellationToken">Cancellation token for the operation</param>
		public static Task AddTaskAsync(this IComputeClient ComputeClient, ClusterId ClusterId, ChannelId ChannelId, RefId TaskRefId, IoHash RequirementsHash, bool SkipCacheLookup, CancellationToken CancellationToken = default)
		{
			return ComputeClient.AddTasksAsync(ClusterId, ChannelId, new[] { TaskRefId }, RequirementsHash, SkipCacheLookup, CancellationToken);
		}
	}
}
