// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "CoreMinimal.h"
#include "Engine/EngineTypes.h"
#include "Containers/ArrayView.h"
#include "Containers/StringView.h"
#include "Containers/BitArray.h"
#include "Containers/List.h"
#include "Misc/StringBuilder.h"
#include "Misc/MemStack.h"
#include "Misc/GeneratedTypeName.h"
#include "Hash/xxhash.h"
#include "HLSLTree/HLSLTreeTypes.h"
#include "HLSLTree/HLSLTreeHash.h"

class FMaterial;
class FMaterialCompilationOutput;
struct FStaticParameterSet;

namespace UE::Shader
{
class FPreshaderData;
}

/**
 * The HLSLTree module contains classes to build an HLSL AST (abstract syntax tree)
 * This allows C++ to procedurally define an HLSL program.  The structure of the tree is designed to be flexible, to facilitate incremental generation from a material node graph
 * Once the tree is complete, HLSL source code may be generated
 */
namespace UE::HLSLTree
{

class FNode;
class FScope;
class FStatement;
class FExpression;
class FFunction;
class FExpressionLocalPHI;
class FRequestedType;

class FEmitContext;
class FEmitScope;
class FEmitShaderExpression;

static constexpr int32 MaxNumPreviousScopes = 2;

class FOwnerContext
{
public:
	virtual ~FOwnerContext() {}

	void PushOwner(UObject* Owner);
	UObject* PopOwner();
	UObject* GetCurrentOwner() const;

private:
	TArray<UObject*, TInlineAllocator<8>> OwnerStack;
};

struct FOwnerScope
{
	FOwnerScope(FOwnerContext& InContext, UObject* InOwner) : Context(&InContext), Owner(InOwner)
	{
		Context->PushOwner(InOwner);
	}

	~FOwnerScope()
	{
		verify(Context->PopOwner() == Owner);
	}

	FOwnerContext* Context;
	UObject* Owner;
};

class FErrorHandlerInterface : public FOwnerContext
{
public:
	virtual ~FErrorHandlerInterface() {}

	int32 GetNumErrors() const { return NumErrors; }
	inline bool HasErrors() const { return NumErrors > 0; }

	template<typename StringType>
	inline bool AddError(const StringType& InError)
	{
		return AddErrorInternalWrapper(FStringView(InError));
	}

	template<typename FormatType, typename... Types>
	inline bool AddErrorf(const FormatType& Format, Types... Args)
	{
		TStringBuilder<2048> String;
		String.Appendf(Format, Forward<Types>(Args)...);
		return AddErrorInternalWrapper(FStringView(String.ToString(), String.Len()));
	}

protected:
	bool AddErrorInternalWrapper(FStringView InError)
	{
		NumErrors++;
		AddErrorInternal(GetCurrentOwner(), InError);
		return false;
	}

	virtual void AddErrorInternal(UObject* InOwner, FStringView InError) = 0;

private:
	int32 NumErrors = 0;
};


/** Root class of the HLSL AST */
class FNode
{
public:
	virtual ~FNode() {}
	virtual void Reset() {}

	UObject* GetOwner() const { return Owner; }

private:
	/** Next node in the FTree's list of all nodes */
	FNode* NextNode = nullptr;

	/** The UObject that owns/created this node, allows errors generated by this node to be properly associated with the owner */
	UObject* Owner = nullptr;

	friend class FTree;
};

struct FEmitPreshaderScope
{
	FEmitPreshaderScope() = default;
	FEmitPreshaderScope(FEmitScope* InScope, FExpression* InValue) : Scope(InScope), Value(InValue) {}

	FEmitScope* Scope = nullptr;
	FExpression* Value = nullptr;
};

/**
 * Represents an HLSL statement.  This is a piece of code that doesn't evaluate to any value, but instead should be executed sequentially, and likely has side-effects.
 * Examples include assigning a value, or various control flow structures (if, for, while, etc)
 * This is an abstract base class, with derived classes representing various types of statements
 */
class FStatement : public FNode
{
public:
	FScope& GetParentScope() const { return *ParentScope; }

	virtual bool IsLoop() const { return false; }

protected:
	virtual bool Prepare(FEmitContext& Context, FEmitScope& Scope) const = 0;
	virtual void EmitShader(FEmitContext& Context, FEmitScope& Scope) const = 0;
	virtual void EmitPreshader(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, TArrayView<const FEmitPreshaderScope> Scopes, Shader::FPreshaderData& OutPreshader) const;

private:
	FScope* ParentScope = nullptr;

	friend class FTree;
	friend class FEmitContext;
	friend class FExpressionLocalPHI;
};

/**
 * Used to initialize FRequestedType with a fixed number of components
 * enum value is the number of parameters
 */
enum class ERequestedType : uint8
{
	Void = 0u,
	Scalar = 1u,
	Texture = 1u, // Currently no different than scalar, just makes code more clear
	Vector2 = 2u,
	Vector3 = 3u,
	Vector4 = 4u,
	Matrix4x4 = 16u,
};

/**
 * Represents a request for an arbitrary set of untyped components
 */
class FRequestedType
{
public:
	FRequestedType() = default;
	FRequestedType(ERequestedType InType);
	FRequestedType(Shader::EValueType InType);
	FRequestedType(const Shader::FType& InType);

	int32 GetNumComponents() const;
	bool IsComponentRequested(int32 Index) const { return RequestedComponents.IsValidIndex(Index) ? (bool)RequestedComponents[Index] : false; }
	bool IsVoid() const { return RequestedComponents.Find(true) == INDEX_NONE; }

	void SetComponentRequest(int32 Index, bool bRequest = true);

	void Reset()
	{
		RequestedComponents.Reset();
	}

	/** Marks the given field as requested (or not) */
	void SetFieldRequested(const Shader::FStructField* Field, bool bRequest = true);
	void ClearFieldRequested(const Shader::FStructField* Field)
	{
		SetFieldRequested(Field, false);
	}

	/** Marks the given field as requested, based on the input request type (which should match the field type) */
	void SetField(const Shader::FStructField* Field, const FRequestedType& InRequest);

	/** Returns the requested type of the given field */
	FRequestedType GetField(const Shader::FStructField* Field) const;

	/** 1 bit per component, a value of 'true' means the specified component is requsted */
	TBitArray<> RequestedComponents;
};
inline bool operator==(const FRequestedType& Lhs, const FRequestedType& Rhs)
{
	return Lhs.RequestedComponents == Rhs.RequestedComponents;
}
inline bool operator!=(const FRequestedType& Lhs, const FRequestedType& Rhs)
{
	return !operator==(Lhs, Rhs);
}

inline void AppendHash(FHasher& Hasher, const FRequestedType& Value)
{
	AppendHash(Hasher, Value.RequestedComponents);
}

struct FPreparedComponent
{
	FPreparedComponent() = default;
	FPreparedComponent(EExpressionEvaluation InEvaluation) : Evaluation(InEvaluation) {}

	inline bool IsNone() const { return Evaluation == EExpressionEvaluation::None; }
	inline bool IsRequested() const { return IsRequestedEvaluation(Evaluation); }

	EExpressionEvaluation GetEvaluation(const FEmitScope& Scope) const;

	FEmitScope* LoopScope = nullptr;
	Shader::FComponentBounds Bounds;
	EExpressionEvaluation Evaluation = EExpressionEvaluation::None;
};
inline bool operator==(const FPreparedComponent& Lhs, const FPreparedComponent& Rhs)
{
	return Lhs.Evaluation == Rhs.Evaluation &&
		Lhs.Bounds == Rhs.Bounds &&
		Lhs.LoopScope == Rhs.LoopScope;
}
inline bool operator!=(const FPreparedComponent& Lhs, const FPreparedComponent& Rhs)
{
	return !operator==(Lhs, Rhs);
}

FPreparedComponent CombineComponents(const FPreparedComponent& Lhs, const FPreparedComponent& Rhs);

/**
 * Like FRequestedType, but tracks an EExpressionEvaluation per component, rather than a simple requested flag
 */
class FPreparedType
{
public:
	FPreparedType() = default;
	FPreparedType(Shader::EValueComponentType InComponentType) : ValueComponentType(InComponentType) {}
	FPreparedType(const Shader::FStructType* InStructType) : StructType(InStructType) {}
	FPreparedType(Shader::EValueType InType, const FPreparedComponent& InComponent = FPreparedComponent());
	FPreparedType(const Shader::FType& InType, const FPreparedComponent& InComponent = FPreparedComponent());

	void SetEvaluation(EExpressionEvaluation Evaluation);
	void MergeEvaluation(EExpressionEvaluation Evaluation);
	void SetLoopEvaluation(FEmitScope& Scope, const FRequestedType& RequestedType);

	void SetField(const Shader::FStructField* Field, const FPreparedType& FieldType);
	FPreparedType GetFieldType(const Shader::FStructField* Field) const;

	int32 GetNumComponents() const;
	FRequestedType GetRequestedType() const;
	FPreparedType GetTypeForRequest(const FRequestedType& RequestedType) const;
	Shader::FType GetType() const;
	const TCHAR* GetName() const { return GetType().GetName(); }
	bool IsStruct() const { return !IsVoid() && StructType != nullptr; }
	bool IsNumeric() const { return !IsVoid() && ValueComponentType != Shader::EValueComponentType::Void; }
	bool IsInitialized() const { return StructType != nullptr || ValueComponentType != Shader::EValueComponentType::Void; }
	bool IsVoid() const;

	EExpressionEvaluation GetEvaluation(const FEmitScope& Scope) const;
	EExpressionEvaluation GetEvaluation(const FEmitScope& Scope, const FRequestedType& RequestedType) const;
	EExpressionEvaluation GetFieldEvaluation(const FEmitScope& Scope, const FRequestedType& RequestedType, int32 ComponentIndex, int32 NumComponents) const;
	Shader::FComponentBounds GetBounds(const FRequestedType& RequestedType) const;
	FPreparedComponent GetMergedComponent() const;

	FPreparedComponent GetComponent(int32 Index) const;
	EExpressionEvaluation GetComponentEvaluation(int32 Index) const { return GetComponent(Index).Evaluation; }
	Shader::FComponentBounds GetComponentBounds(int32 Index) const;

	void SetComponent(int32 Index, const FPreparedComponent& InComponent);
	void SetComponentBounds(int32 Index, const Shader::FComponentBounds Bounds);
	void MergeComponent(int32 Index, const FPreparedComponent& InComponent);

	/** Unlike FRequestedType, one of these should be set */
	const Shader::FStructType* StructType = nullptr;
	Shader::EValueComponentType ValueComponentType = Shader::EValueComponentType::Void;

	void EnsureNumComponents(int32 NumComponents);

	/** Evaluation type for each component, may be 'None' for components that are unused */
	TArray<FPreparedComponent, TInlineAllocator<4>> PreparedComponents;
};
inline bool operator==(const FPreparedType& Lhs, const FPreparedType& Rhs)
{
	return Lhs.ValueComponentType == Rhs.ValueComponentType &&
		Lhs.StructType == Rhs.StructType &&
		Lhs.PreparedComponents == Rhs.PreparedComponents;
}
inline bool operator!=(const FPreparedType& Lhs, const FPreparedType& Rhs)
{
	return !operator==(Lhs, Rhs);
}

FPreparedType MergePreparedTypes(const FPreparedType& Lhs, const FPreparedType& Rhs);
FPreparedType MakeNonLWCType(const FPreparedType& Type);

class FPrepareValueResult
{
public:
	const FPreparedType& GetPreparedType() const { return PreparedType; }

	bool SetTypeVoid();

	bool SetType(FEmitContext& Context, const FRequestedType& RequestedType, EExpressionEvaluation Evaluation, const Shader::FType& Type);
	bool SetType(FEmitContext& Context, const FRequestedType& RequestedType, const FPreparedType& Type);

private:
	bool TryMergePreparedType(FEmitContext& Context, const Shader::FStructType* StructType, Shader::EValueComponentType ComponentType);

	FPreparedType PreparedType;

	friend class FExpression;
	friend class FEmitContext;
};

struct FEmitValueShaderResult
{
	FEmitShaderExpression* Code = nullptr;
};

struct FEmitValuePreshaderResult
{
	explicit FEmitValuePreshaderResult(Shader::FPreshaderData& InPreshader) : Preshader(InPreshader) {}

	Shader::FPreshaderData& Preshader;
	Shader::FType Type;
};

enum class EDerivativeCoordinate : uint8
{
	Ddx,
	Ddy,
};

struct FExpressionDerivatives
{
	FExpression* ExpressionDdx = nullptr;
	FExpression* ExpressionDdy = nullptr;

	FExpression* Get(EDerivativeCoordinate Coord) const { return (Coord == EDerivativeCoordinate::Ddx) ? ExpressionDdx : ExpressionDdy; }

	bool IsValid() const { return (bool)ExpressionDdx && (bool)ExpressionDdy; }
};

/**
 * Represents an HLSL expression.  This is a piece of code that evaluates to a value, but has no side effects.
 * Unlike statements, expressions are not expected to execute in any particular order.  They may be cached (or not) in generated code, without the underlying implementation needing to care.
 * Examples include constant literals, variable accessors, and various types of math operations
 * This is an abstract base class, with derived classes representing various types of expression
 */
class FExpression : public FNode
{
public:
	const FPreparedType& GetPreparedType() const { return PrepareValueResult.PreparedType; }
	FRequestedType GetRequestedType() const { return PrepareValueResult.PreparedType.GetRequestedType(); }
	Shader::FType GetType() const { return PrepareValueResult.PreparedType.GetType(); }
	EExpressionEvaluation GetEvaluation(const FEmitScope& Scope, const FRequestedType& RequestedType) const { return PrepareValueResult.PreparedType.GetEvaluation(Scope, RequestedType); }

	virtual void Reset() override;

	FEmitShaderExpression* GetValueShader(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType);
	Shader::FType GetValuePreshader(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, Shader::FPreshaderData& OutPreshader);
	Shader::FValue GetValueConstant(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType);

	FEmitShaderExpression* GetValueShader(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, const Shader::FType& ResultType);
	FEmitShaderExpression* GetValueShader(FEmitContext& Context, FEmitScope& Scope, const Shader::FType& ResultType);
	FEmitShaderExpression* GetValueShader(FEmitContext& Context, FEmitScope& Scope, Shader::EValueType ResultType);
	FEmitShaderExpression* GetValueShader(FEmitContext& Context, FEmitScope& Scope);

	Shader::FValue GetValueConstant(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, const Shader::FType& ResultType);
	Shader::FValue GetValueConstant(FEmitContext& Context, FEmitScope& Scope, const Shader::FType& ResultType);
	Shader::FValue GetValueConstant(FEmitContext& Context, FEmitScope& Scope, Shader::EValueType ResultType);

protected:
	virtual void ComputeAnalyticDerivatives(FTree& Tree, FExpressionDerivatives& OutResult) const;
	virtual FExpression* ComputePreviousFrame(FTree& Tree, const FRequestedType& RequestedType) const;
	virtual bool PrepareValue(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, FPrepareValueResult& OutResult) const = 0;
	virtual void EmitValueShader(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, FEmitValueShaderResult& OutResult) const;
	virtual void EmitValuePreshader(FEmitContext& Context, FEmitScope& Scope, const FRequestedType& RequestedType, FEmitValuePreshaderResult& OutResult) const;

private:
	FExpressionDerivatives Derivatives;
	FPrepareValueResult PrepareValueResult;
	bool bReentryFlag = false;
	bool bComputedDerivatives = false;

	friend class FTree;
	friend class FEmitContext;
	friend class FExpressionReentryScope;
};

class FExpressionReentryScope
{
public:
	FExpressionReentryScope(FExpression* InExpression) : Expression(InExpression)
	{
		if (Expression)
		{
			check(!Expression->bReentryFlag);
			Expression->bReentryFlag = true;
		}
	}

	~FExpressionReentryScope()
	{
		if (Expression)
		{
			check(Expression->bReentryFlag);
			Expression->bReentryFlag = false;
		}
	}

	FExpression* Expression;
};

class FFunction final : public FNode
{
public:
	FScope& GetRootScope() const { return *RootScope; }

	FScope* RootScope = nullptr;
	FScope* CalledScope = nullptr;
	TArray<FExpression*, TInlineAllocator<8>> OutputExpressions;
};

/**
 * Represents an HLSL scope.  A scope contains a single statement, along with any expressions required by that statement
 */
class FScope final : public FNode
{
public:
	static FScope* FindSharedParent(FScope* Lhs, FScope* Rhs);

	inline FScope* GetParentScope() const { return ParentScope; }

	inline TArrayView<FScope*> GetPreviousScopes() const
	{
		// const_cast needed, otherwise type of array view is 'FScope*const' which doesn't make sense
		return MakeArrayView(const_cast<FScope*>(this)->PreviousScope, NumPreviousScopes);
	}

	bool HasParentScope(const FScope& ParentScope) const;

	void AddPreviousScope(FScope& Scope);


private:
	friend class FTree;
	friend class FExpression;
	friend class FEmitContext;

	FScope* ParentScope = nullptr;
	FStatement* OwnerStatement = nullptr;
	FStatement* ContainedStatement = nullptr;
	FScope* PreviousScope[MaxNumPreviousScopes];
	TMap<FName, FExpression*> LocalMap;
	int32 NumPreviousScopes = 0;
	int32 NestedLevel = 0;
};

/**
 * The HLSL AST.  Basically a wrapper around the root scope, with some helper methods
 */
class FTree : public FOwnerContext
{
public:
	static FTree* Create(FMemStackBase& Allocator);
	static void Destroy(FTree* Tree);

	FMemStackBase& GetAllocator() { return *Allocator; }

	void ResetNodes();

	bool Finalize();

	bool EmitShader(FEmitContext& Context, FStringBuilderBase& OutCode) const;

	FScope& GetRootScope() const { return *RootScope; }

	template<typename T, typename... ArgTypes>
	inline FExpression* NewExpression(ArgTypes&&... Args)
	{
		FHasher Hasher;
		AppendHash(Hasher, GetGeneratedTypeName<T>());
		AppendHashes(Hasher, Forward<ArgTypes>(Args)...);
		const FXxHash64 Hash = Hasher.Finalize();
		FExpression* Expression = FindExpression(Hash);
		if (!Expression)
		{
			T* TypedExpression = NewNode<T>(Forward<ArgTypes>(Args)...);
			RegisterExpression(TypedExpression, Hash);
			Expression = TypedExpression;
		}
		return Expression;
	}

	template<typename T, typename... ArgTypes>
	inline T* NewStatement(FScope& Scope, ArgTypes&&... Args)
	{
		T* Statement = NewNode<T>(Forward<ArgTypes>(Args)...);
		RegisterStatement(Scope, Statement);
		return Statement;
	}

	void AssignLocal(FScope& Scope, const FName& LocalName, FExpression* Value);
	FExpression* AcquireLocal(FScope& Scope, const FName& LocalName);

	FExpression* NewFunctionCall(FScope& Scope, FFunction* Function, int32 OutputIndex);

	const FExpressionDerivatives& GetAnalyticDerivatives(FExpression* InExpression);
	FExpression* GetPreviousFrame(FExpression* InExpression, const FRequestedType& RequestedType);

	FScope* NewScope(FScope& Scope);
	FScope* NewOwnedScope(FStatement& Owner);
	FFunction* NewFunction();

	/** Shortcuts to create various common expression types */
	FExpression* NewConstant(const Shader::FValue& Value);
	FExpression* NewUnaryOp(EOperation Op, FExpression* Input);
	FExpression* NewBinaryOp(EOperation Op, FExpression* Lhs, FExpression* Rhs);

	FExpression* NewAbs(FExpression* Input) { return NewUnaryOp(EOperation::Abs, Input); }
	FExpression* NewNeg(FExpression* Input) { return NewUnaryOp(EOperation::Neg, Input); }
	FExpression* NewSaturate(FExpression* Input) { return NewUnaryOp(EOperation::Saturate, Input); }
	FExpression* NewSum(FExpression* Input) { return NewUnaryOp(EOperation::Sum, Input); }
	FExpression* NewRcp(FExpression* Input) { return NewUnaryOp(EOperation::Rcp, Input); }
	FExpression* NewSqrt(FExpression* Input) { return NewUnaryOp(EOperation::Sqrt, Input); }
	FExpression* NewRsqrt(FExpression* Input) { return NewUnaryOp(EOperation::Rsqrt, Input); }
	FExpression* NewLog2(FExpression* Input) { return NewUnaryOp(EOperation::Log2, Input); }
	FExpression* NewExp2(FExpression* Input) { return NewUnaryOp(EOperation::Exp2, Input); }
	FExpression* NewFrac(FExpression* Input) { return NewUnaryOp(EOperation::Frac, Input); }
	FExpression* NewLength(FExpression* Input) { return NewUnaryOp(EOperation::Length, Input); }
	FExpression* NewNormalize(FExpression* Input) { return NewUnaryOp(EOperation::Normalize, Input); }
	FExpression* NewSin(FExpression* Input) { return NewUnaryOp(EOperation::Sin, Input); }
	FExpression* NewCos(FExpression* Input) { return NewUnaryOp(EOperation::Cos, Input); }

	FExpression* NewAdd(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::Add, Lhs, Rhs); }
	FExpression* NewSub(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::Sub, Lhs, Rhs); }
	FExpression* NewMul(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::Mul, Lhs, Rhs); }
	FExpression* NewDiv(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::Div, Lhs, Rhs); }
	FExpression* NewFmod(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::Fmod, Lhs, Rhs); }
	FExpression* NewMin(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::Min, Lhs, Rhs); }
	FExpression* NewMax(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::Max, Lhs, Rhs); }
	FExpression* NewLess(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::Less, Lhs, Rhs); }
	FExpression* NewGreater(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::Greater, Lhs, Rhs); }
	FExpression* NewLessEqual(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::LessEqual, Lhs, Rhs); }
	FExpression* NewGreaterEqual(FExpression* Lhs, FExpression* Rhs) { return NewBinaryOp(EOperation::GreaterEqual, Lhs, Rhs); }

	FExpression* NewPow2(FExpression* Input) { return NewMul(Input, Input); }
	FExpression* NewCross(FExpression* Lhs, FExpression* Rhs);
	FExpression* NewDot(FExpression* Lhs, FExpression* Rhs) { return NewSum(NewMul(Lhs, Rhs)); }
	FExpression* NewLerp(FExpression* A, FExpression* B, FExpression* T) { return NewAdd(A, NewMul(NewSub(B, A), T)); }

private:
	template<typename T, typename... ArgTypes>
	inline T* NewNode(ArgTypes&&... Args)
	{
		T* Node = new(*Allocator) T(Forward<ArgTypes>(Args)...);
		RegisterNode(Node);
		return Node;
	}

	void RegisterNode(FNode* Node);
	void RegisterExpression(FExpression* Expression, FXxHash64 Hash);
	void RegisterExpression(FExpressionLocalPHI* Expression, FXxHash64 Hash);
	void RegisterStatement(FScope& Scope, FStatement* Statement);
	FExpression* FindExpression(FXxHash64 Hash) const;

	FMemStackBase* Allocator = nullptr;
	FNode* Nodes = nullptr;
	FScope* RootScope = nullptr;
	TMap<FXxHash64, FExpression*> ExpressionMap;
	TArray<FExpressionLocalPHI*> PHIExpressions;
	TArray<UObject*, TInlineAllocator<8>> OwnerStack;

	friend class FExpressionLocalPHI;
};

} // namespace UE::HLSLTree

